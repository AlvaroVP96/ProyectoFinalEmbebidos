\documentclass[12pt,a4paper]{article}
\usepackage[spanish]{babel}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{xcolor}
\usepackage{listings}
\usepackage{geometry}
\geometry{margin=2.5cm}

\makeatother

\lstset{
  language=python,
  basicstyle=\ttfamily\small,
  keywordstyle=\color{blue},
  stringstyle=\color{red},
  commentstyle=\color{gray},
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny\color{gray},
  frame=single,
  breaklines=true,
  literate={á}{{\'a}}1 {é}{{\'e}}1 {í}{{\'i}}1 {ó}{{\'o}}1 {ú}{{\'u}}1
           {Á}{{\'A}}1 {É}{{\'E}}1 {Í}{{\'I}}1 {Ó}{{\'O}}1 {Ú}{{\'U}}1
}


\begin{document}

\begin{titlepage}
    \centering
    
    % --- Título ---
    {\Huge \textbf{Proyecto Beaglebone}\par}
    \vspace{0.5cm}
    
    % --- Subtítulo ---
    {\Large Sistemas Embebidos\par}
    \vspace{1cm}
    {\Large Máster Universitario de Informática Industrial y Robótica.\par}
    \vspace{2cm}
    
    % --- Autor ---
    {\large Autor: Álvaro Viña Pérez\par}
    {\large Fecha: \today\par}

    \vspace{3cm}

    % --- Logo o imagen principal ---
    \includegraphics[scale=0.5]{figuras/f88b6ddd233f3e7a0354031500455b1d3873dd94.png}\par\vspace{1cm}
    
    \vfill  % empuja el texto inferior al final de la página
    
    \begin{flushright}
        \includegraphics[width=0.35\textwidth]{figuras/Marca-Universidad-de-La-Laguna_RGB.png}
    \end{flushright}
\end{titlepage}


\newpage
\tableofcontents
\newpage

\section{Descripción general}
Este proyecto constituye una fase preparatoria fundamental para el desarrollo del proyecto final 
de la asignatura Sistemas Embebidos del Máster Universitario de Informática Industrial y 
Robótica. La implementación se ha realizado utilizando una placa BeagleBone Black, que 
desempeña un doble rol en la arquitectura del sistema: actuando simultáneamente como broker 
MQTT (servidor de mensajería) y como cliente MQTT.

La plataforma BeagleBone Black ha sido configurada con un servidor web basado en Flask, 
un framework ligero y potente para desarrollo web en Python. Este servidor proporciona una 
interfaz web intuitiva que permite la visualización en tiempo real de los datos recibidos a 
través del protocolo MQTT.

El sistema implementa una arquitectura publish-subscribe mediante el protocolo MQTT 
(Message Queuing Telemetry Transport), ampliamente utilizado en aplicaciones IoT (Internet 
of Things) por su eficiencia y bajo consumo de recursos. En este esquema, la BeagleBone 
actúa como:

\begin{itemize}
    \item \textbf{Broker MQTT:} Gestiona la comunicación entre diferentes dispositivos, 
    recibiendo mensajes de los publicadores (publishers) y distribuyéndolos a los suscriptores 
    (subscribers) según los tópicos correspondientes.
    
    \item \textbf{Cliente MQTT:} Se suscribe a tópicos específicos para recibir datos que 
    posteriormente son procesados y mostrados en la interfaz web.
\end{itemize}

La interfaz web desarrollada en Flask permite a los usuarios monitorizar de forma 
remota los datos capturados por el sistema, ofreciendo una solución completa de adquisición,
procesamiento y visualización de información en sistemas embebidos. Esta arquitectura 
proporciona una base sólida para comprender los fundamentos de la comunicación IoT y el 
desarrollo de aplicaciones web en plataformas embebidas.

\subsection{Sincronización de código con Visual Studio Code}

Para facilitar el desarrollo y la transferencia de archivos entre el ordenador de desarrollo 
y la BeagleBone Black, se utilizó la extensión SFTP de Visual Studio Code. Esta herramienta 
permite sincronizar automáticamente los archivos del proyecto mediante el protocolo SFTP 
(SSH File Transfer Protocol).

La configuración se realiza mediante un archivo JSON (\texttt{sftp.json}) ubicado en la 
carpeta \texttt{.vscode} del proyecto:

\begin{lstlisting}[language=C++]
{
    "name": "BeagleBone",
    "host": "192.168.7.2",
    "protocol": "sftp",
    "port": 22,
    "username": "debian",
    "password": "temppwd",
    "remotePath": "/home/debian/Proyectos",
    "localPath": "./",
    "uploadOnSave": true,
    "syncMode": "update",
    "watcher": {
        "files": "**/*",
        "autoUpload": true,
        "autoDelete": true  
    }
}
\end{lstlisting}

Los parámetros más relevantes de esta configuración son:

\begin{itemize}
    \item \textbf{host}: Dirección IP de la BeagleBone (192.168.7.2 corresponde a la 
    conexión USB directa).
    \item \textbf{uploadOnSave}: Activa la carga automática de archivos cada vez que 
    se guardan cambios en Visual Studio Code.
    \item \textbf{syncMode}: Modo de sincronización que solo actualiza archivos 
    modificados.
    \item \textbf{watcher}: Observador que detecta automáticamente cambios en los 
    archivos del proyecto y los sincroniza en tiempo real.
\end{itemize}

Esta configuración agiliza significativamente el proceso de desarrollo, permitiendo 
editar el código en el entorno familiar de Visual Studio Code y visualizar los cambios 
inmediatamente en la BeagleBone sin necesidad de transferencias manuales mediante SCP 
o FTP.


\subsection{Configuración de la BeagleBone como Broker MQTT}

El primer paso para implementar el sistema de comunicación MQTT consiste en configurar 
la BeagleBone Black como broker MQTT. Para ello, utilizaremos Mosquitto, un broker MQTT 
de código abierto ligero y eficiente, ideal para sistemas embebidos.

\subsubsection{Instalación de Mosquitto}

La instalación de Mosquitto en la BeagleBone Black se realiza mediante los siguientes 
comandos en el sistema Debian:

\begin{lstlisting}[language=bash]
# Actualizar la lista de paquetes
sudo apt-get update

# Instalar Mosquitto broker y cliente
sudo apt-get install mosquitto mosquitto-clients

# Habilitar el servicio para que inicie automaticamente
sudo systemctl enable mosquitto

# Iniciar el servicio Mosquitto
sudo systemctl start mosquitto
\end{lstlisting}

Para verificar que el servicio está ejecutándose correctamente:

\begin{lstlisting}[language=bash]
# Comprobar el estado del servicio
sudo systemctl status mosquitto
\end{lstlisting}

\subsubsection{Configuración del Broker}

Una vez instalado, es necesario configurar Mosquitto para permitir las conexiones. 
El archivo de configuración se encuentra en \texttt{/etc/mosquitto/mosquitto.conf}. 
Se debe editar con los siguientes comandos:

\begin{lstlisting}[language=bash]
# Editar el archivo de configuracion
sudo nano /etc/mosquitto/mosquitto.conf
\end{lstlisting}

Se debe añadir o modificar las siguientes líneas para permitir conexiones:

\begin{lstlisting}
listener 1883
allow_anonymous true
\end{lstlisting}

Tras modificar la configuración, es necesario reiniciar el servicio:

\begin{lstlisting}[language=bash]
# Reiniciar el servicio Mosquitto
sudo systemctl restart mosquitto
\end{lstlisting}

\subsection{Verificación del sistema MQTT}

\subsubsection{Comunicación local: BeagleBone como cliente y broker}

Una vez configurado el broker, se realizaron pruebas de comunicación local donde la 
BeagleBone actúa simultáneamente como broker y cliente MQTT. Para ello se utilizaron 
dos terminales:

Terminal 1 (Suscriptor):
\begin{lstlisting}[language=bash]
mosquitto_sub -h localhost -t test/topic
\end{lstlisting}

Terminal 2 (Publicador):
\begin{lstlisting}[language=bash]
mosquitto_pub -h localhost -t test/topic -m "Hola desde BeagleBone"
\end{lstlisting}

\begin{figure}[h]
    \centering
    \includegraphics[width=0.8\textwidth]{figuras/beagleboneBroker-beagleboneClient.png}
    \caption{Comunicación MQTT local entre cliente y broker en la BeagleBone}
    \label{fig:comunicacion_local}
\end{figure}

\subsubsection{Integración con el servidor web Flask}

El siguiente paso consistió en verificar la comunicación entre un cliente MQTT que 
publica mensajes y el servidor web Flask, que se suscribe a los tópicos correspondientes 
para mostrar los datos recibidos en tiempo real mediante la interfaz web.

\begin{figure}[h]
    \centering
    \includegraphics[width=0.8\textwidth]{figuras/beaglebone-web.png}
    \caption{Visualización de mensajes MQTT en la interfaz web Flask desde el navegador}
    \label{fig:flask_mqtt}
\end{figure}

\subsubsection{Comunicación con MQTT Explorer}

Finalmente, se utilizó MQTT Explorer, una herramienta gráfica para la gestión y 
monitorización de comunicaciones MQTT, para validar el correcto funcionamiento del 
sistema completo. Esta herramienta permite visualizar todos los tópicos disponibles, 
publicar mensajes y suscribirse a tópicos de forma intuitiva.

\begin{figure}[h]
    \centering
    \includegraphics[width=0.8\textwidth]{figuras/MQTTprueba.png}
    \caption{Comunicación entre MQTT Explorer y el broker en la BeagleBone, 
    con visualización simultánea en la interfaz web}
    \label{fig:mqtt_explorer}
\end{figure}

Estas pruebas confirmaron el correcto funcionamiento de la arquitectura implementada, 
validando tanto la capacidad del broker para gestionar múltiples clientes como la 
integración exitosa con la interfaz web de visualización.

\subsection{Desarrollo e integración de la interfaz web}

Una vez validada la comunicación MQTT y confirmado el correcto funcionamiento del broker, 
se procedió al desarrollo de la interfaz web utilizando el framework Flask. Esta interfaz 
permite visualizar en tiempo real los datos recibidos a través del protocolo MQTT, 
proporcionando una solución completa de monitorización remota.

\subsubsection{Proceso de puesta en marcha y validación}

El proceso de validación del sistema completo se realizó siguiendo los siguientes pasos:

\paragraph{\textbf{Paso 1: Inicialización del servidor Flask}}

El servidor web se ejecuta desde la BeagleBone mediante el siguiente comando en terminal:

\begin{lstlisting}[language=bash]
python -m flask --app Interfaz run --host=0.0.0.0
\end{lstlisting}

Este comando inicia el servidor Flask en modo accesible desde cualquier dispositivo en 
la red local. El código completo de la aplicación \texttt{Interfaz.py} se detalla en 
la sección codigo fuente.

\begin{figure}[h]
    \centering
    \includegraphics[width=0.6\textwidth]{figuras/arranqueinterfaz.png}
    \caption{Ejecución del servidor Flask en la BeagleBone}
    \label{fig:flask_startup}
\end{figure}

\begin{figure}[h]
    \centering
    \includegraphics[width=0.6\textwidth]{figuras/interfaz.png}
    \caption{Interfaz web flask}
    \label{fig:flask_interfaz}
\end{figure}

\paragraph{\textbf{Paso 2: Configuración de MQTT Explorer}}

Se configura MQTT Explorer estableciendo la conexión con el broker mediante la dirección 
IP de la BeagleBone. Esta herramienta permite gestionar de forma gráfica las publicaciones 
y suscripciones a los diferentes tópicos MQTT configurados en el sistema.

\begin{figure}[h]
    \centering
    \includegraphics[width=0.8\textwidth]{figuras/confimqtt.png}
    \caption{Configuración de la conexión en MQTT Explorer}
    \label{fig:mqtt_explorer_config}
\end{figure}


\paragraph{\textbf{Paso 3: Publicación de mensajes}}

Utilizando MQTT Explorer, se selecciona uno de los tópicos configurados en el sistema 
y se publica un mensaje de prueba. La interfaz permite especificar tanto el tópico de 
destino como el contenido del mensaje a publicar.

\begin{figure}[h]
    \centering
    \includegraphics[width=0.4\textwidth]{figuras/publish.png}
    \caption{Publicación de mensaje en un tópico mediante MQTT Explorer}
    \label{fig:mqtt_explorer_publish}
\end{figure}

\paragraph{\textbf{Paso 4: Visualización en la interfaz web}}

Finalmente, se observa en la interfaz web cómo el valor del tópico se actualiza 
automáticamente en tiempo real, reflejando el mensaje publicado. Este comportamiento 
confirma el correcto funcionamiento de toda la cadena de comunicación: desde la 
publicación del mensaje, su gestión por el broker, hasta su visualización en la 
aplicación web.

\begin{figure}[h]
    \centering
    \includegraphics[width=0.8\textwidth]{figuras/actualizacionInterfaz.png}
    \caption{Actualización en tiempo real de los datos en la interfaz web}
    \label{fig:web_interface_update}
\end{figure}

Este proceso de validación demuestra la correcta integración de todos los componentes 
del sistema: el broker MQTT, el cliente de publicación, el servidor Flask y la interfaz 
de usuario web.

\newpage
\section{Código fuente}
\label{sec:codigofuente}
\begin{lstlisting}

from flask import Flask, render_template_string
import paho.mqtt.client as mqtt
import threading

app = Flask(__name__)

# Variable global para almacenar el último mensaje recibido
ultimo_mensaje_temp = "Esperando actualización..."
ultimo_mensaje_hum = "Esperando actualización..."
ultimo_mensaje_door1 = "Esperando actualización..."
ultimo_mensaje_door2 = "Esperando actualización..."

# Configuración MQTT
MQTT_BROKER = "localhost"
MQTT_PORT = 1883
MQTT_TOPIC_TEMP = "Sensores/temperatura"
MQTT_TOPIC_HUM = "Sensores/humedad"
MQTT_TOPIC_DOOR_1 = "Sensores/Puertas/Puerta1"
MQTT_TOPIC_DOOR_2 = "Sensores/Puertas/Puerta2"

# Callback cuando se conecta al broker MQTT
def on_connect(client, userdata, flags, rc, properties=None):
    print(f"Conectado al broker MQTT con código: {rc}")
    client.subscribe(MQTT_TOPIC_TEMP)
    client.subscribe(MQTT_TOPIC_HUM)
    client.subscribe(MQTT_TOPIC_DOOR_1)
    client.subscribe(MQTT_TOPIC_DOOR_2)
    print(f"Suscrito al topic: {MQTT_TOPIC_TEMP}")
    print(f"Suscrito al topic: {MQTT_TOPIC_HUM}")
    print(f"Suscrito al topic: {MQTT_TOPIC_DOOR_1}")
    print(f"Suscrito al topic: {MQTT_TOPIC_DOOR_2}")



# Callback cuando se recibe un mensaje
def on_message(client, userdata, msg):
    global ultimo_mensaje_temp, ultimo_mensaje_hum,ultimo_mensaje_door2,ultimo_mensaje_door1
    
    # Verificar de qué topic viene el mensaje
    if msg.topic == MQTT_TOPIC_TEMP:
        ultimo_mensaje_temp = msg.payload.decode()
        print(f"Mensaje temperatura recibido: {ultimo_mensaje_temp}")
    elif msg.topic == MQTT_TOPIC_HUM:
        ultimo_mensaje_hum = msg.payload.decode()
        print(f"Mensaje humedad recibido: {ultimo_mensaje_hum}")
    elif msg.topic == MQTT_TOPIC_DOOR_1:
        ultimo_mensaje_door1 = msg.payload.decode()
        print(f"Mensaje humedad recibido: {ultimo_mensaje_door1}")
    elif msg.topic == MQTT_TOPIC_DOOR_2:
        ultimo_mensaje_door2 = msg.payload.decode()
        print(f"Mensaje humedad recibido: {ultimo_mensaje_door2}")

# Inicializar cliente MQTT
mqtt_client = mqtt.Client(mqtt.CallbackAPIVersion.VERSION2)
mqtt_client.on_connect = on_connect
mqtt_client.on_message = on_message

# Conectar al broker en un hilo separado
def start_mqtt():
    mqtt_client.connect(MQTT_BROKER, MQTT_PORT, 60)
    mqtt_client.loop_forever()

# Iniciar MQTT en segundo plano
mqtt_thread = threading.Thread(target=start_mqtt, daemon=True)
mqtt_thread.start()

HTML_TEMPLATE = """
<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Monitor MQTT - Sistema de Sensores</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        header {
            background: white;
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            margin-bottom: 30px;
            text-align: center;
        }
        
        h1 {
            color: #333;
            font-size: 2.5em;
            margin-bottom: 10px;
        }
        
        .status {
            display: inline-block;
            padding: 8px 20px;
            background: #4CAF50;
            color: white;
            border-radius: 20px;
            font-size: 0.9em;
        }
        
        .dashboard {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }
        
        .card {
            background: white;
            padding: 25px;
            border-radius: 15px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
            transition: transform 0.3s ease;
        }
        
        .card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 25px rgba(0,0,0,0.2);
        }
        
        .card h2 {
            color: #667eea;
            font-size: 1.3em;
            margin-bottom: 15px;
            border-bottom: 2px solid #667eea;
            padding-bottom: 10px;
        }
        
        .message-box {
            background: #f5f5f5;
            padding: 20px;
            border-radius: 10px;
            border-left: 4px solid #667eea;
            font-family: 'Courier New', monospace;
            font-size: 1.1em;
            color: #333;
            word-wrap: break-word;
        }
        
        .info {
            margin-top: 15px;
            font-size: 0.9em;
            color: #666;
        }
        
        .topic-badge {
            background: #e3f2fd;
            color: #1976d2;
            padding: 5px 10px;
            border-radius: 5px;
            font-family: monospace;
        }
        
        .timestamp {
            text-align: right;
            color: #999;
            font-size: 0.85em;
            margin-top: 10px;
        }
        
        @media (max-width: 768px) {
            h1 {
                font-size: 1.8em;
            }
            
            .dashboard {
                grid-template-columns: 1fr;
            }
        }
    </style>
    <script>
        // Auto-refresh cada 2 segundos
        setTimeout(function(){
            location.reload();
        }, 2000);
    </script>
</head>
<body>
    <div class="container">
        <header>
            <h1>Monitor MQTT</h1>
            <span class="status">Conectado</span>
        </header>
        
        <div class="dashboard">
            <div class="card">
                <h2>Sensor Temperatura</h2>
                <div class="message-box">
                    {{ mensaje_temp }}
                </div>
                <div class="info">
                    <strong>Topic:</strong> <span class="topic-badge">{{ topic_temp }}</span>
                </div>
                <div class="timestamp">
                    Actualizado automáticamente cada 2 segundos
                </div>
            </div>

            <div class="card">
                <h2>Sensor Humedad</h2>
                <div class="message-box">
                    {{ mensaje_hum }}
                </div>
                <div class="info">
                    <strong>Topic:</strong> <span class="topic-badge">{{ topic_hum }}</span>
                </div>
                <div class="timestamp">
                    Actualizado automáticamente cada 2 segundos
                </div>
            </div>
            
             <div class="card">
                <h2>Puerta Exterior</h2>
                <div class="message-box">
                    {{ mensaje_door1 }}
                </div>
                <div class="info">
                    <strong>Topic:</strong> <span class="topic-badge">{{ topic_door1 }}</span>
                </div>
                <div class="timestamp">
                    Actualizado automáticamente cada 2 segundos
                </div>
            </div>

             <div class="card">
                <h2>Puerta Interior</h2>
                <div class="message-box">
                    {{ mensaje_door2 }}
                </div>
                <div class="info">
                    <strong>Topic:</strong> <span class="topic-badge">{{ topic_door2 }}</span>
                </div>
                <div class="timestamp">
                    Actualizado automáticamente cada 2 segundos
                </div>
            </div>
            
            <!-- Aquí irán más cards cuando agregues los topics -->
        </div>
    </div>
</body>
</html>
"""

@app.route("/")
def index():
    return render_template_string(
        HTML_TEMPLATE,
        mensaje_hum=ultimo_mensaje_hum,
        mensaje_temp=ultimo_mensaje_temp,
        mensaje_door1=ultimo_mensaje_door1,
        mensaje_door2=ultimo_mensaje_door2,
        topic_temp=MQTT_TOPIC_TEMP,
        topic_hum=MQTT_TOPIC_HUM,
        topic_door1=MQTT_TOPIC_DOOR_1,
        topic_door2=MQTT_TOPIC_DOOR_2
    )

if __name__ == "__main__":
    app.run(debug=True, host='0.0.0.0', port=5000)


\end{lstlisting}

\newpage

\section{Explicación del código}

El código desarrollado integra un servidor web Flask con un cliente MQTT, permitiendo 
la visualización en tiempo real de datos provenientes de diferentes sensores. A 
continuación se detalla la estructura y funcionamiento de cada componente:

\subsection{Importación de librerías}

\begin{lstlisting}[language=Python]
from flask import Flask, render_template_string
import paho.mqtt.client as mqtt
import threading
\end{lstlisting}

El programa utiliza tres librerías principales:
\begin{itemize}
    \item \textbf{Flask}: Framework web ligero que proporciona las funcionalidades de 
    servidor HTTP y renderizado de plantillas HTML.
    \item \textbf{paho.mqtt.client}: Biblioteca cliente MQTT que permite la suscripción 
    a tópicos y la gestión de mensajes mediante callbacks.
    \item \textbf{threading}: Módulo de Python para la ejecución concurrente, necesario 
    para ejecutar simultáneamente el servidor Flask y el cliente MQTT.
\end{itemize}

\subsection{Inicialización y variables globales}

\begin{lstlisting}[language=Python]
app = Flask(__name__)

ultimo_mensaje_temp = "Esperando actualización..."
ultimo_mensaje_hum = "Esperando actualización..."
ultimo_mensaje_door1 = "Esperando actualización..."
ultimo_mensaje_door2 = "Esperando actualización..."
\end{lstlisting}

Se crea la instancia de la aplicación Flask y se definen cuatro variables globales que 
almacenarán los últimos mensajes recibidos de cada tópico MQTT. Estas variables actúan 
como buffer de datos entre el cliente MQTT y la interfaz web.

\subsection{Configuración MQTT}

\begin{lstlisting}[language=Python]
MQTT_BROKER = "localhost"
MQTT_PORT = 1883
MQTT_TOPIC_TEMP = "Sensores/temperatura"
MQTT_TOPIC_HUM = "Sensores/humedad"
MQTT_TOPIC_DOOR_1 = "Sensores/Puertas/Puerta1"
MQTT_TOPIC_DOOR_2 = "Sensores/Puertas/Puerta2"
\end{lstlisting}

Se definen los parámetros de conexión al broker MQTT:
\begin{itemize}
    \item \textbf{MQTT\_BROKER}: Dirección del broker (localhost indica que el broker 
    se ejecuta en la misma BeagleBone).
    \item \textbf{MQTT\_PORT}: Puerto estándar para comunicación MQTT (1883).
    \item \textbf{MQTT\_TOPIC\_*}: Jerarquía de tópicos a los que el cliente se suscribirá.
\end{itemize}

\subsection{Funciones callback MQTT}

\subsubsection{Callback de conexión}

\begin{lstlisting}[language=Python]
def on_connect(client, userdata, flags, rc, properties=None):
    print(f"Conectado al broker MQTT con código: {rc}")
    client.subscribe(MQTT_TOPIC_TEMP)
    client.subscribe(MQTT_TOPIC_HUM)
    client.subscribe(MQTT_TOPIC_DOOR_1)
    client.subscribe(MQTT_TOPIC_DOOR_2)
\end{lstlisting}

Esta función se ejecuta automáticamente cuando el cliente establece conexión con el 
broker. El parámetro \texttt{rc} (return code) indica el estado de la conexión (0 = éxito). 
Tras conectarse, el cliente se suscribe a los cuatro tópicos configurados.

\subsubsection{Callback de recepción de mensajes}

\begin{lstlisting}[language=Python]
def on_message(client, userdata, msg):
    global ultimo_mensaje_temp, ultimo_mensaje_hum, ultimo_mensaje_door2, ultimo_mensaje_door1
    
    if msg.topic == MQTT_TOPIC_TEMP:
        ultimo_mensaje_temp = msg.payload.decode()
        print(f"Mensaje temperatura recibido: {ultimo_mensaje_temp}")
    elif msg.topic == MQTT_TOPIC_HUM:
        ultimo_mensaje_hum = msg.payload.decode()
        print(f"Mensaje humedad recibido: {ultimo_mensaje_hum}")
    # ...
\end{lstlisting}

Esta función se invoca cada vez que llega un mensaje a uno de los tópicos suscritos. 
El código:
\begin{enumerate}
    \item Identifica el tópico de origen mediante \texttt{msg.topic}.
    \item Decodifica el payload (contenido del mensaje) de bytes a string.
    \item Actualiza la variable global correspondiente.
    \item Registra el evento en consola para depuración.
\end{enumerate}

\subsection{Inicialización del cliente MQTT}

\begin{lstlisting}[language=Python]
mqtt_client = mqtt.Client(mqtt.CallbackAPIVersion.VERSION2)
mqtt_client.on_connect = on_connect
mqtt_client.on_message = on_message
\end{lstlisting}

Se crea una instancia del cliente MQTT especificando la versión de la API de callbacks 
(VERSION2). Posteriormente se asignan las funciones callback definidas anteriormente.

\subsection{Ejecución concurrente del cliente MQTT}

\begin{lstlisting}[language=Python]
def start_mqtt():
    mqtt_client.connect(MQTT_BROKER, MQTT_PORT, 60)
    mqtt_client.loop_forever()

mqtt_thread = threading.Thread(target=start_mqtt, daemon=True)
mqtt_thread.start()
\end{lstlisting}

Para que el cliente MQTT y el servidor Flask puedan ejecutarse simultáneamente:
\begin{itemize}
    \item Se define \texttt{start\_mqtt()} que establece la conexión y mantiene un 
    bucle infinito escuchando mensajes.
    \item Se crea un hilo daemon (se cerrará automáticamente cuando termine el programa 
    principal).
    \item Se inicia el hilo inmediatamente al arrancar la aplicación.
\end{itemize}

\subsection{Plantilla HTML y estilos CSS}

La variable \texttt{HTML\_TEMPLATE} contiene una plantilla HTML completa con:

\subsubsection{Estructura HTML}
\begin{itemize}
    \item Diseño responsivo mediante \texttt{viewport}.
    \item Rejilla adaptativa (\texttt{grid}) que organiza las tarjetas de sensores.
    \item Sistema de plantillas Jinja2 (sintaxis \texttt{\{\{ variable \}\}}) para 
    inyección dinámica de datos.
\end{itemize}

\subsubsection{Estilos CSS}
\begin{itemize}
    \item Degradado de fondo (\texttt{linear-gradient}).
    \item Tarjetas con efecto hover (elevación y sombra).
    \item Diseño responsivo con \texttt{media queries} para dispositivos móviles.
    \item Sistema de colores consistente para badges y mensajes.
\end{itemize}

\subsubsection{JavaScript de actualización}
\begin{lstlisting}[language=HTML]
<script>
    setTimeout(function(){
        location.reload();
    }, 2000);
</script>
\end{lstlisting}

Este script recarga automáticamente la página cada 2 segundos, permitiendo visualizar 
los datos actualizados sin intervención manual del usuario. Esta aproximación simple 
es adecuada para este proyecto, aunque en sistemas de producción se recomendaría 
utilizar WebSockets para actualizaciones en tiempo real sin recargas.

\subsection{Ruta Flask y renderizado}

\begin{lstlisting}[language=Python]
@app.route("/")
def index():
    return render_template_string(
        HTML_TEMPLATE,
        mensaje_hum=ultimo_mensaje_hum,
        mensaje_temp=ultimo_mensaje_temp,
        mensaje_door1=ultimo_mensaje_door1,
        mensaje_door2=ultimo_mensaje_door2,
        topic_temp=MQTT_TOPIC_TEMP,
        topic_hum=MQTT_TOPIC_HUM,
        topic_door1=MQTT_TOPIC_DOOR_1,
        topic_door2=MQTT_TOPIC_DOOR_2
    )
\end{lstlisting}

El decorador \texttt{@app.route("/")} define la ruta raíz del servidor web. Cuando un 
cliente accede a esta URL:
\begin{enumerate}
    \item Se ejecuta la función \texttt{index()}.
    \item Se renderiza la plantilla HTML inyectando los valores actuales de las variables 
    globales.
    \item Se envía el HTML generado al navegador del cliente.
\end{enumerate}

Esta función se ejecuta cada vez que la página se recarga (cada 2 segundos), mostrando 
siempre los valores más recientes recibidos por MQTT.

\subsection{Punto de entrada principal}

\begin{lstlisting}[language=Python]
if __name__ == "__main__":
    app.run(debug=True, host='0.0.0.0', port=5000)
\end{lstlisting}

Esta sección se ejecuta únicamente cuando el script se ejecuta directamente (no cuando 
se importa como módulo):
\begin{itemize}
    \item \textbf{debug=True}: Habilita el modo de depuración (recarga automática ante 
    cambios en el código y mensajes de error detallados).
    \item \textbf{host='0.0.0.0'}: Permite conexiones desde cualquier dirección IP de 
    la red, no solo localhost.
    \item \textbf{port=5000}: Puerto en el que escucha el servidor Flask.
\end{itemize}

\subsection{Flujo de ejecución completo}

El funcionamiento integrado del sistema sigue este flujo:
\begin{enumerate}
    \item Al iniciar el script, se crea el hilo MQTT que se conecta al broker y se 
    suscribe a los tópicos.
    \item El servidor Flask inicia en el hilo principal, quedando a la espera de 
    peticiones HTTP.
    \item Cuando llega un mensaje MQTT, \texttt{on\_message} actualiza las variables 
    globales.
    \item Un usuario accede a la interfaz web mediante su navegador.
    \item Flask renderiza la plantilla HTML con los valores actuales.
    \item JavaScript recarga la página cada 2 segundos, repitiendo el proceso.
\end{enumerate}

Esta arquitectura permite una separación clara de responsabilidades: el cliente MQTT 
gestiona la comunicación con el broker de forma asíncrona, mientras Flask se encarga 
exclusivamente de servir la interfaz web con los datos más recientes disponibles.

\section{Conclusiones}

Este proyecto ha permitido implementar con éxito un sistema completo de monitorización 
basado en el protocolo MQTT, integrando una BeagleBone Black que actúa simultáneamente 
como broker y cliente MQTT, junto con una interfaz web desarrollada en Flask para la 
visualización de datos en tiempo real.

Los principales logros alcanzados incluyen:

\begin{itemize}
    \item \textbf{Configuración exitosa del broker Mosquitto:} Se ha establecido un 
    broker MQTT funcional en la BeagleBone Black, capaz de gestionar múltiples clientes 
    y tópicos de forma eficiente.
    
    \item \textbf{Desarrollo de una interfaz web intuitiva:} La implementación en Flask 
    proporciona una visualización clara y accesible de los datos provenientes de cuatro 
    tópicos diferentes (temperatura, humedad y dos sensores de puerta), con actualización 
    automática cada 2 segundos.
    
    \item \textbf{Validación exhaustiva del sistema:} Las pruebas realizadas con 
    comunicación local, MQTT Explorer y la interfaz web han confirmado el correcto 
    funcionamiento de todos los componentes de la arquitectura.
    
    \item \textbf{Arquitectura modular y escalable:} El diseño implementado permite 
    añadir fácilmente nuevos sensores o tópicos MQTT simplemente extendiendo las 
    variables globales y la plantilla HTML.
\end{itemize}

Durante el desarrollo del proyecto se han adquirido competencias fundamentales en:

\begin{itemize}
    \item Configuración y administración de sistemas embebidos basados en Linux (Debian).
    \item Implementación de comunicaciones IoT mediante el protocolo MQTT.
    \item Desarrollo de aplicaciones web en Python utilizando el framework Flask.
    \item Programación concurrente mediante threading para gestión de múltiples procesos.
    \item Integración de diferentes tecnologías (MQTT, Flask, HTML/CSS/JavaScript) en 
    una solución completa.
\end{itemize}

Este trabajo constituye una base sólida para el desarrollo del proyecto final de la 
asignatura, habiendo establecido una infraestructura robusta de comunicación y 
visualización que podrá ser extendida con funcionalidades adicionales como:

\begin{itemize}
    \item Almacenamiento persistente de datos históricos en bases de datos.
    \item Implementación de actuadores controlables remotamente vía MQTT.
    \item Mejora de la interfaz web mediante WebSockets para eliminación de recargas.
    \item Incorporación de sistemas de autenticación y seguridad en las comunicaciones.
    \item Análisis y visualización avanzada de datos mediante gráficas temporales.
\end{itemize}

En conclusión, el proyecto ha cumplido satisfactoriamente con los objetivos planteados, 
demostrando la viabilidad de implementar sistemas IoT completos en plataformas embebidas 
como la BeagleBone Black, y proporcionando una experiencia práctica valiosa en el diseño 
e implementación de arquitecturas publish-subscribe para sistemas embebidos.

\end{document}
